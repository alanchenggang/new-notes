---
title: MySQL索引详解
date: 2021-10-26 22:58:36.93
updated: 2021-10-29 14:07:32.631
url: /archives/mysqlindexbasic
categories: MySQL
tags: 基础 | MySQL | 索引
---

### 索引的定义

---

1. MySQL 官方对索引的定义为 :索引是帮助 MySQL 高效获取数据的数据结构.由此可见索引的本质:索引是数据结构

2. 索引的目的在于提高查找效率

3. 排好序的快速查找数据结构

---
### 索引的优劣

---
- 优势
1. 提高数据检索的效率 降低数据库的IO成本
2. 降低数据排序的成本 降低CPU的小号

- 劣势
1. 降低更新表效率 更新表内容也需要更新索引
2. 占用更多的磁盘空间

---
### 索引的分类

#### 1. 单值索引
	一个索引只包含单个列,一个表可以有多个单列索引
#### 2. 唯一索引
	索引列的值必须唯一,但允许有空值
#### 3. 复合索引
	一个索引包含多个列
#### 4. 基本语法
```sql
	-- 创建
	CREATE [UNIQUE] INDEX INDEXNAME ON TABLE(COLUMNNAME(LENGTH));
	
	ALTER TABLE ADD [UNIQUE] INDEX[INDEXNAME] ON (COLUMNNAME(LENGTH));
	-- 删除
	DROP INDEX [INDEXNAME] ON TABLENAME;
	-- 查看
	SHOW INDEX FROM TABLENAME\G
```

### Explain语句

> 使用EXPLAIN关键字可以模拟优化器执行SQL查询语句,从而知道MySQL是如何处理你的SQL语句的.用来对查询语句或是表结构的性能瓶颈

```sql
EXPLAIN SQL;
```

![image-20211026224319880](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/javabasic/image-20211026224319880.png)

1. id 字段 标识表的读取顺序 id相同则从上往下顺序执行 id值越大 优先级越高 该表最先被读取

2. select_type字段 

   - SIMPLE --> 简单的 SELECT 查询,查询中不包含子查询或者 UNION
   - PRIMARY  -->查询中若包含任何复杂的子部分,最外层查询标记为 PRIMARY  
   - SUBQUERY -->  在 SELECT  或  WHERE  列表中包含了子查询
   - DERIVED ---> 在 FROM 列表中包含的子查询被标记为 DERIVED  (衍生)  MySQL会递归执行这些子查询,把结果放入临时表
   - UNION ---> 若第二个 SELECT 出现在UNION之后,则被标记为 UNION ;若 UNION包含在 FROM 子句的子查询中,外层 SELECT 将被标记为 DERIVED 
   - UNIUN RESULT -->从 UNION 表获取结果的 SELECT

3.  type 字段

   显示查询使用了何种类型

   - system  表中只有一行记录(等于系统表) 是 const 的特例
   - const  表示通过索引一次就找到了
   - eq_ref  唯一性索引扫描,对于每个索引值,表中只有一条记录与之匹配,常用于比较主键索引和唯一索引 
   - ref 非唯一性索引扫描,返回匹配某个单独值的所有行 本质上也是一种索引访问  查找与扫描的混合体
   - range 只检索给定范围的行,使用一个索引来选择行 一般就是在where语句中出现了between < > in 等的查询
   - index  全索引扫描 遍历索引树 索引文件通常比数据文件小
   - ALL  全表扫描

   **从最好到最差依次是:** system > const > eq_ref > range > index >ALL

4. possible_keys 

   ​	显示可能应用在这张表上的索引,一个或多个

   ​	查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询实际使用

5. key

   ​	实际使用的索引 如果为null 则没有使用索引

   ​	查询中若使用了覆盖索引,则该索引仅出现在key列表中

6. key_len 

   ​	表示索引中使用的字节数,可通过该列计算查询中使用的索引的长度,在不损失精确性的情况下,长度越短越好   显示的值为索引字段的最大可能长度 **并非实际使用长度** 即 key_len 是根据表定义计算而得,并非通过表内检索出的

7. ref

   ​	显示索引的那一列被使用了,如果可能的话,是一个常数.那些列或常量被用于查找索引列上的值

8. rows

   ​	根据表统计信息及索引选用情况,大致估算出找到所需的记录所需要读取的行数

9. Extra 额外信息

    - Using filesort  MySQL无法利用索引完成的排序操作 (文件外排序)  !优化

    - Using temporary 使用了临时表保存中间结果 常见于order by 或 group by !优化

    - Using index 表示相应的查询操作使用了覆盖索引 避免了访问表的数据行
      如果同时出现了using where 表明索引被用来执行索引键值的查找
      如果没有同时出现using where 表明索引被用来读取数据而非执行查找动作

      **覆盖索引:**

      ​	查询列要被所建的索引覆盖: select的数据列只用从索引中就能取得,不必读取数据行,MySQL可以利用索引返回select列表中的字段,而不必根据索引再次读取数据文件(有关系即可)

    - Using where 表明使用where过滤

    - Using join buffer 使用了连接缓存

    - impossible where where条件逻辑错乱 总为false

---
###  索引优化查询案例

#### 单表:  测试index如何加 (范围判断会导致索引失效)

#### 两表:  左右连接索引加在附表中相应的列上

#### 三表:  索引都加在附表中 

#### 结论:

- 尽可能减少join语句中的嵌套循环的循环总次数:"永远用小结果集驱动大的结果集" ----> **小表驱动大表**
- 优先优化嵌套循环的内层循环
- 保证join语句中被驱动表上join条件字段已经被索引
- 当无法保证被驱动表的join条件字段被索引且内存资源充足的条件下,不要太吝啬joinbuffer的设置

---
## 索引优化
---
### 索引失效(应该避免)
- 全值匹配最优

- 最佳左前缀法则: 如果索引了多列.要遵循最左前缀法则:查询从索引的最左前列开始并且不能跳过索引中的列

- 不要在索引列上做任何操作(计算/函数/(自动or手动类型转换)),会导致索引失效而转向全表扫描

- 存储引擎-不能使用索引中范围条件右边的列

- 尽量使用覆盖索引(索引列和查询列一致),减少select星

- MySQL在使用不等于(!=或<>)的时候无法使用索引而导致全表扫描

- is null ,is not null也无法使用索引

- like以通配符开头索引失效会变成全表扫描操作

  问题: 如何解决like '%字符串%'时索引不被使用的方法?

  > 使用覆盖索引达到目的 避免全表扫描

- 字符串不加单引号索引失效

- 少用or 用它来连接时会导致索引失效
### 总结:
> **1.带头大哥不能死**
>
> **2.中间兄弟不能断**
>
> **3.索引列上不计算**
>
> **4.范围之后全失效**
>
> **5. like 百分加右边**
>
> **6. 字符串必有引号**

### 主键索引自增的优点

>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。
>
>**如果我们使用自增主键**，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次**插入一条新记录，都是追加操作，不需要重新移动数据**，因此这种插入数据的方法效率非常高。
>
>**如果我们使用非自增主键**，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为**页分裂**。**页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率**。
>
>主键索引使用自增主键,插入相当于有序数组的插入递增元素,直接在表尾插入即可
>
>主键索引不使用自增主键,插入相当于有序数组的插入随机元素,最坏的情况下数组中每个元素都需要移动一遍

### 索引字段设置NOT NULL的好处

- 第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。
- 第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，会导致更多的存储空间占用，因为 InnoDB 默认行存储格式`COMPACT`，会用 1 字节空间存储 NULL 值列表

### 防止MySQL索引失效

MySQL索引失效的情况:

- 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；

- 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；

- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。

- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

可以通过查询SQL的执行计划判断该SQL运行是否命中索引,查询SQL执行计划用关键字*explain*

对于执行计划，参数有：

- possible_keys 字段表示可能用到的索引；
- key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；
- key_len 表示索引的长度；
- rows 表示扫描的数据行数。
- type 表示数据扫描类型

type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的**执行效率从低到高的顺序为**：

- All（全表扫描）；
- index（全索引扫描）；
- range（索引范围扫描）；
- ref（非唯一索引扫描）；
- eq_ref（唯一索引扫描）；
- const（结果只有一条的主键或唯一索引扫描）

Extra 额外的信息说明

>EXPLAIN输出的Extra列包含有关MySQL如何解析查询的其他信息。此字段能够给出让我们深入理解执行计划进一步的细节信息，比如是否使用ICP，MRR等

常见的参考指标有:

- Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。
- Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。
- Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。

### 二级索引(辅助索引)

**二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。**

常用的二级索引包括：

1. **唯一索引(Unique Key)** ：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
2. **普通索引(Index)** ：**普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。**
3. **前缀索引(Prefix)** ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。

在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：

- 先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；
- 然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。

上面这个过程叫做**回表**

我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据，这个过程叫做**覆盖索引**
