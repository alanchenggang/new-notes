---
title: MySQL索引详解
date: 2021-10-26 22:58:36.93
updated: 2021-10-29 14:07:32.631
url: /archives/mysqlindexbasic
categories: MySQL
tags: 基础 | MySQL | 索引
---

### 索引的定义

---

1. MySQL 官方对索引的定义为 :索引是帮助 MySQL 高效获取数据的数据结构.由此可见索引的本质:索引是数据结构

2. 索引的目的在于提高查找效率

3. 排好序的快速查找数据结构

---
### 索引的优劣

---
- 优势
1. 提高数据检索的效率 降低数据库的IO成本
2. 降低数据排序的成本 降低CPU的小号

- 劣势
1. 降低更新表效率 更新表内容也需要更新索引
2. 占用更多的磁盘空间

---
### 索引的分类

#### 1. 单值索引
	一个索引只包含单个列,一个表可以有多个单列索引
#### 2. 唯一索引
	索引列的值必须唯一,但允许有空值
#### 3. 复合索引
	一个索引包含多个列
#### 4. 基本语法
```sql
	-- 创建
	CREATE [UNIQUE] INDEX INDEXNAME ON TABLE(COLUMNNAME(LENGTH));
	
	ALTER TABLE ADD [UNIQUE] INDEX[INDEXNAME] ON (COLUMNNAME(LENGTH));
	-- 删除
	DROP INDEX [INDEXNAME] ON TABLENAME;
	-- 查看
	SHOW INDEX FROM TABLENAME\G
```

### Explain语句

> 使用EXPLAIN关键字可以模拟优化器执行SQL查询语句,从而知道MySQL是如何处理你的SQL语句的.用来对查询语句或是表结构的性能瓶颈

```sql
EXPLAIN SQL;
```

![image-20211026224319880](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/javabasic/image-20211026224319880.png)

1. id 字段 标识表的读取顺序 id相同则从上往下顺序执行 id值越大 优先级越高 该表最先被读取

2. select_type字段 

   - SIMPLE --> 简单的 SELECT 查询,查询中不包含子查询或者 UNION
   - PRIMARY  -->查询中若包含任何复杂的子部分,最外层查询标记为 PRIMARY  
   - SUBQUERY -->  在 SELECT  或  WHERE  列表中包含了子查询
   - DERIVED ---> 在 FROM 列表中包含的子查询被标记为 DERIVED  (衍生)  MySQL会递归执行这些子查询,把结果放入临时表
   - UNION ---> 若第二个 SELECT 出现在UNION之后,则被标记为 UNION ;若 UNION包含在 FROM 子句的子查询中,外层 SELECT 将被标记为 DERIVED 
   - UNIUN RESULT -->从 UNION 表获取结果的 SELECT

3.  type 字段

   显示查询使用了何种类型

   - system  表中只有一行记录(等于系统表) 是 const 的特例
   - const  表示通过索引一次就找到了
   - eq_ref  唯一性索引扫描,对于每个索引值,表中只有一条记录与之匹配,常用于比较主键索引和唯一索引 
   - ref 非唯一性索引扫描,返回匹配某个单独值的所有行 本质上也是一种索引访问  查找与扫描的混合体
   - range 只检索给定范围的行,使用一个索引来选择行 一般就是在where语句中出现了between < > in 等的查询
   - index  全索引扫描 遍历索引树 索引文件通常比数据文件小
   - ALL  全表扫描

   **从最好到最差依次是:** system > const > eq_ref > range > index >ALL

4. possible_keys 

   ​	显示可能应用在这张表上的索引,一个或多个

   ​	查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询实际使用

5. key

   ​	实际使用的索引 如果为null 则没有使用索引

   ​	查询中若使用了覆盖索引,则该索引仅出现在key列表中

6. key_len 

   ​	表示索引中使用的字节数,可通过该列计算查询中使用的索引的长度,在不损失精确性的情况下,长度越短越好   显示的值为索引字段的最大可能长度 **并非实际使用长度** 即 key_len 是根据表定义计算而得,并非通过表内检索出的

7. ref

   ​	显示索引的那一列被使用了,如果可能的话,是一个常数.那些列或常量被用于查找索引列上的值

8. rows

   ​	根据表统计信息及索引选用情况,大致估算出找到所需的记录所需要读取的行数

9. Extra 额外信息

    - Using filesort  MySQL无法利用索引完成的排序操作 (文件外排序)  !优化

    - Using temporary 使用了临时表保存中间结果 常见于order by 或 group by !优化

    - Using index 表示相应的查询操作使用了覆盖索引 避免了访问表的数据行
      如果同时出现了using where 表明索引被用来执行索引键值的查找
      如果没有同时出现using where 表明索引被用来读取数据而非执行查找动作

      **覆盖索引:**

      ​	查询列要被所建的索引覆盖: select的数据列只用从索引中就能取得,不必读取数据行,MySQL可以利用索引返回select列表中的字段,而不必根据索引再次读取数据文件(有关系即可)

    - Using where 表明使用where过滤

    - Using join buffer 使用了连接缓存

    - impossible where where条件逻辑错乱 总为false

---
###  索引优化查询案例

#### 单表:  测试index如何加 (范围判断会导致索引失效)

#### 两表:  左右连接索引加在附表中相应的列上

#### 三表:  索引都加在附表中 

#### 结论:

- 尽可能减少join语句中的嵌套循环的循环总次数:"永远用小结果集驱动大的结果集" ----> **小表驱动大表**
- 优先优化嵌套循环的内层循环
- 保证join语句中被驱动表上join条件字段已经被索引
- 当无法保证被驱动表的join条件字段被索引且内存资源充足的条件下,不要太吝啬joinbuffer的设置

---
## 索引优化
---
### 索引失效(应该避免)
- 全值匹配最优

- 最佳左前缀法则: 如果索引了多列.要遵循最左前缀法则:查询从索引的最左前列开始并且不能跳过索引中的列

- 不要在索引列上做任何操作(计算/函数/(自动or手动类型转换)),会导致索引失效而转向全表扫描

- 存储引擎-不能使用索引中范围条件右边的列

- 尽量使用覆盖索引(索引列和查询列一致),减少select星

- MySQL在使用不等于(!=或<>)的时候无法使用索引而导致全表扫描

- is null ,is not null也无法使用索引

- like以通配符开头索引失效会变成全表扫描操作

  问题: 如何解决like '%字符串%'时索引不被使用的方法?

  > 使用覆盖索引达到目的 避免全表扫描

- 字符串不加单引号索引失效

- 少用or 用它来连接时会导致索引失效
### 总结:
> **1.带头大哥不能死**
>
> **2.中间兄弟不能断**
>
> **3.索引列上不计算**
>
> **4.范围之后全失效**
>
> **5. like 百分加右边**
>
> **6. 字符串必有引号**

### 主键索引自增的优点

>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。
>
>**如果我们使用自增主键**，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次**插入一条新记录，都是追加操作，不需要重新移动数据**，因此这种插入数据的方法效率非常高。
>
>**如果我们使用非自增主键**，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为**页分裂**。**页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率**。
>
>主键索引使用自增主键,插入相当于有序数组的插入递增元素,直接在表尾插入即可
>
>主键索引不使用自增主键,插入相当于有序数组的插入随机元素,最坏的情况下数组中每个元素都需要移动一遍

### 索引字段设置NOT NULL的好处

- 第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。
- 第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，会导致更多的存储空间占用，因为 InnoDB 默认行存储格式`COMPACT`，会用 1 字节空间存储 NULL 值列表

### 防止MySQL索引失效

MySQL索引失效的情况:

- 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；

- 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；

- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。

- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

可以通过查询SQL的执行计划判断该SQL运行是否命中索引,查询SQL执行计划用关键字*explain*

对于执行计划，参数有：

- possible_keys 字段表示可能用到的索引；
- key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；
- key_len 表示索引的长度；
- rows 表示扫描的数据行数。
- type 表示数据扫描类型

type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的**执行效率从低到高的顺序为**：

- All（全表扫描）；
- index（全索引扫描）；
- range（索引范围扫描）；
- ref（非唯一索引扫描）；
- eq_ref（唯一索引扫描）；
- const（结果只有一条的主键或唯一索引扫描）

Extra 额外的信息说明

>EXPLAIN输出的Extra列包含有关MySQL如何解析查询的其他信息。此字段能够给出让我们深入理解执行计划进一步的细节信息，比如是否使用ICP，MRR等

常见的参考指标有:

- Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。
- Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。
- Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。

### 二级索引(辅助索引)

**二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。**

常用的二级索引包括：

1. **唯一索引(Unique Key)** ：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
2. **普通索引(Index)** ：**普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。**
3. **前缀索引(Prefix)** ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。

在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：

- 先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；
- 然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。

上面这个过程叫做**回表**

我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据，这个过程叫做**覆盖索引**

### InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？

- 持久性是通过 redo log （重做日志）来保证的；

- 原子性是通过 undo log（回滚日志） 来保证的；

- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；

- 一致性则是通过持久性+原子性+隔离性来保证

  **在同时处理多个事务的时候，就可能出现脏读（dirty read **如果一个事务「读到」了另一个「未提交事务修改过的数据」**）、不可重复读（non-repeatable read  **在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况**）、幻读（phantom read **在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况**）的问题**

SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

- **读未提交（\*read uncommitted\*）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（\*read committed\*）**，指一个事务提交之后，它做的变更才能被其他事务看到；**Oracle默认隔离级别**
- **可重复读（\*repeatable read\*）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（\*serializable\* ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

>- 在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；
>- 在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；
>- 在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；
>- 在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。

**MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，解决的方案有两种：

- 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

### 隔离级别的实现

- 对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
- 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
- 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View \**来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。\**「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View**

**MVCC中的Read View**

Read View 有四个重要的字段：

- m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的**事务 id 列表**，注意是一个列表，**“活跃事务”指的就是，启动了但还没提交的事务**。
- min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 **id 最小的事务**，也就是 m_ids 的最小值。
- max_trx_id ：这个并不是 m_ids 的最大值，而是**创建 Read View 时当前数据库中应该给下一个事务的 id 值**，也就是全局事务中最大的事务 id 值 + 1；
- creator_trx_id ：指的是**创建该 Read View 的事务的事务 id**。

对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：

- trx_id，当一个事务对某条聚簇索引记录进行改动时，就会**把该事务的事务 id 记录在 trx_id 隐藏列里**；
- roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后**这个隐藏列是个指针，指向每一个旧版本记录**，于是就可以通过它找到修改前的记录。

![img](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/java/image/ReadView.drawio.png)

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：

- 如果记录的 trx_id 值小于 Read View 中的 `min_trx_id` 值，表示这个版本的记录是在创建 Read View **前**已经提交的事务生成的，所以该版本的记录对当前事务**可见**。
- 如果记录的 trx_id 值大于等于 Read View 中的 `max_trx_id` 值，表示这个版本的记录是在创建 Read View **后**才启动的事务生成的，所以该版本的记录对当前事务**不可见**。
- 如果记录的 trx_id 值在 Read View 的min_trx_id和max_trx_id之间，需要判断 trx_id 是否在 m_ids 列表中：
  - 如果记录的 trx_id **在** `m_ids` 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务**不可见**。
  - 如果记录的 trx_id **不在** `m_ids`列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见**。

**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）**

### 可重复读的实现

**可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View**	

对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：

- trx_id，当一个事务对某条聚簇索引记录进行改动时，就会**把该事务的事务 id 记录在 trx_id 隐藏列里**；
- roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后**这个隐藏列是个指针，指向每一个旧版本记录**，于是就可以通过它找到修改前的记录。

当事务对行中字段进行update后,MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成**版本链**

**多事务读过程中,需要判断 trx_id 值是否在m_ids 范围内，如果判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时读事务 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」读事务 的 Read View 中的 min_trx_id 值的第一条记录**

### 读已提交的实现

**读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View**

## MySQL InnoDB 引擎的默认隔离级别「可重复读」与幻读现象

解决的方案有两种：

- 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

#### 什么是幻读

当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题

#### 快照读解决方案

可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是启动事务后，在执行第一个查询语句后，会创建一个 Read View，**后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的**

####  当前读解决方案

MySQL 里除了普通查询是快照读，其他都是**当前读**，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据 `select ... for update` 这种查询语句是当前读，每次执行的时候都是读取最新的数据

**Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了间隙锁**。

![img](https://img-blog.csdnimg.cn/3af285a8e70f4d4198318057eb955520.png?)

事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）。

然后，事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是事物 B 会生成一个插入意向锁，同时进入等待状态，直到事务 A 提交了事务。这就避免了由于事务 B 插入新记录而导致事务 A 发生幻读的现象。

**可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读**

## MySQL当中的锁

![image-20221028170852252](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/javabasic/image-20221028170852252.png)

### 全局锁

> 全局锁是怎么用的？

要使用全局锁，则要执行这条命：

```sql
flush tables with read lock
```

执行后，**整个数据库就处于只读状态了**，这时其他线程执行以下操作，都会被阻塞：

- 对数据的增删改操作，比如 insert、delete、update等语句；
- 对表结构的更改操作，比如 alter table、drop table 等语句。

如果要释放全局锁，则要执行这条命令：

```sql
unlock tables
```

当会话断开了，全局锁会被自动释放

全局锁主要应用于做**全库逻辑备份**(非事务性的存储引擎)，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 `–single-transaction` 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。

InnoDB 存储引擎默认的事务隔离级别是可重复读，因此可以采用这种方式来备份数据库。

## 表级锁

```sql
//对读取的记录加共享锁
select ... lock in share mode;

//对读取的记录加独占锁
select ... for update;
```

### MySQL 主键递增的好处有哪些

