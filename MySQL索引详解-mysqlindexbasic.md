---
title: MySQL索引详解
date: 2021-10-26 22:58:36.93
updated: 2021-10-29 14:07:32.631
url: /archives/mysqlindexbasic
categories: MySQL
tags: 基础 | MySQL | 索引
---

### 索引的定义

---

1. MySQL 官方对索引的定义为 :索引是帮助 MySQL 高效获取数据的数据结构.由此可见索引的本质:索引是数据结构

2. 索引的目的在于提高查找效率

3. 排好序的快速查找数据结构

---
### 索引的优劣

---
- 优势
1. 提高数据检索的效率 降低数据库的IO成本
2. 降低数据排序的成本 降低CPU的小号

- 劣势
1. 降低更新表效率 更新表内容也需要更新索引
2. 占用更多的磁盘空间

---
### 索引的分类

#### 1. 单值索引
	一个索引只包含单个列,一个表可以有多个单列索引
#### 2. 唯一索引
	索引列的值必须唯一,但允许有空值
#### 3. 复合索引
	一个索引包含多个列
#### 4. 基本语法
```sql
	-- 创建
	CREATE [UNIQUE] INDEX INDEXNAME ON TABLE(COLUMNNAME(LENGTH));
	
	ALTER TABLE ADD [UNIQUE] INDEX[INDEXNAME] ON (COLUMNNAME(LENGTH));
	-- 删除
	DROP INDEX [INDEXNAME] ON TABLENAME;
	-- 查看
	SHOW INDEX FROM TABLENAME\G
```

### Explain语句

> 使用EXPLAIN关键字可以模拟优化器执行SQL查询语句,从而知道MySQL是如何处理你的SQL语句的.用来对查询语句或是表结构的性能瓶颈

```sql
EXPLAIN SQL;
```

![image-20211026224319880](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/javabasic/image-20211026224319880.png)

1. id 字段 标识表的读取顺序 id相同则从上往下顺序执行 id值越大 优先级越高 该表最先被读取

2. select_type字段 

   - SIMPLE --> 简单的 SELECT 查询,查询中不包含子查询或者 UNION
   - PRIMARY  -->查询中若包含任何复杂的子部分,最外层查询标记为 PRIMARY  
   - SUBQUERY -->  在 SELECT  或  WHERE  列表中包含了子查询
   - DERIVED ---> 在 FROM 列表中包含的子查询被标记为 DERIVED  (衍生)  MySQL会递归执行这些子查询,把结果放入临时表
   - UNION ---> 若第二个 SELECT 出现在UNION之后,则被标记为 UNION ;若 UNION包含在 FROM 子句的子查询中,外层 SELECT 将被标记为 DERIVED 
   - UNIUN RESULT -->从 UNION 表获取结果的 SELECT

3.  type 字段

   显示查询使用了何种类型

   - system  表中只有一行记录(等于系统表) 是 const 的特例
   - const  表示通过索引一次就找到了
   - eq_ref  唯一性索引扫描,对于每个索引值,表中只有一条记录与之匹配,常用于比较主键索引和唯一索引 
   - ref 非唯一性索引扫描,返回匹配某个单独值的所有行 本质上也是一种索引访问  查找与扫描的混合体
   - range 只检索给定范围的行,使用一个索引来选择行 一般就是在where语句中出现了between < > in 等的查询
   - index  全索引扫描 遍历索引树 索引文件通常比数据文件小
   - ALL  全表扫描

   **从最好到最差依次是:** system > const > eq_ref > range > index >ALL

4. possible_keys 

   ​	显示可能应用在这张表上的索引,一个或多个

   ​	查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询实际使用

5. key

   ​	实际使用的索引 如果为null 则没有使用索引

   ​	查询中若使用了覆盖索引,则该索引仅出现在key列表中

6. key_len 

   ​	表示索引中使用的字节数,可通过该列计算查询中使用的索引的长度,在不损失精确性的情况下,长度越短越好   显示的值为索引字段的最大可能长度 **并非实际使用长度** 即 key_len 是根据表定义计算而得,并非通过表内检索出的

7. ref

   ​	显示索引的那一列被使用了,如果可能的话,是一个常数.那些列或常量被用于查找索引列上的值

8. rows

   ​	根据表统计信息及索引选用情况,大致估算出找到所需的记录所需要读取的行数

9. Extra 额外信息

    - Using filesort  MySQL无法利用索引完成的排序操作 (文件外排序)  !优化

    - Using temporary 使用了临时表保存中间结果 常见于order by 或 group by !优化

    - Using index 表示相应的查询操作使用了覆盖索引 避免了访问表的数据行
      如果同时出现了using where 表明索引被用来执行索引键值的查找
      如果没有同时出现using where 表明索引被用来读取数据而非执行查找动作

      **覆盖索引:**

      ​	查询列要被所建的索引覆盖: select的数据列只用从索引中就能取得,不必读取数据行,MySQL可以利用索引返回select列表中的字段,而不必根据索引再次读取数据文件(有关系即可)

    - Using where 表明使用where过滤

    - Using join buffer 使用了连接缓存

    - impossible where where条件逻辑错乱 总为false

---
###  索引优化查询案例

#### 单表:  测试index如何加 (范围判断会导致索引失效)

#### 两表:  左右连接索引加在附表中相应的列上

#### 三表:  索引都加在附表中 

#### 结论:

- 尽可能减少join语句中的嵌套循环的循环总次数:"永远用小结果集驱动大的结果集" ----> **小表驱动大表**
- 优先优化嵌套循环的内层循环
- 保证join语句中被驱动表上join条件字段已经被索引
- 当无法保证被驱动表的join条件字段被索引且内存资源充足的条件下,不要太吝啬joinbuffer的设置

---
## 索引优化
---
### 索引失效(应该避免)
- 全值匹配最优

- 最佳左前缀法则: 如果索引了多列.要遵循最左前缀法则:查询从索引的最左前列开始并且不能跳过索引中的列

- 不要在索引列上做任何操作(计算/函数/(自动or手动类型转换)),会导致索引失效而转向全表扫描

- 存储引擎-不能使用索引中范围条件右边的列

- 尽量使用覆盖索引(索引列和查询列一致),减少select星

- MySQL在使用不等于(!=或<>)的时候无法使用索引而导致全表扫描

- is null ,is not null也无法使用索引

- like以通配符开头索引失效会变成全表扫描操作

  问题: 如何解决like '%字符串%'时索引不被使用的方法?

  > 使用覆盖索引达到目的 避免全表扫描

- 字符串不加单引号索引失效

- 少用or 用它来连接时会导致索引失效
### 总结:
> **1.带头大哥不能死**
>
> **2.中间兄弟不能断**
>
> **3.索引列上不计算**
>
> **4.范围之后全失效**
>
> **5. like 百分加右边**
>
> **6. 字符串必有引号**

